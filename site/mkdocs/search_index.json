{
    "docs": [
        {
            "location": "/", 
            "text": "Coding for Journalists\n\n\nThis class is an evolving introduction to coding and the Python programming language for journalists. In addition to a tour of the fundamentals, it spans nine basic projects to get you started.\n\n\nThe \nfirst version\n of this course happened at the \n2015 IRE Conference in Philadelphia\n; the repository and associated tasks have been updated since.\n\n\nA few things to note before we get rolling:\n\n\n\n\nThis guide and all documentation live at \ncoding-for-journalists.rtfd.org\n\n\nThe GitHub repository that includes all code is available from \ngithub.com/ireapps/coding-for-journalists\n\n\nA good place to raise issues with the code or ask specific questions about the code is \nalso on GitHub\n\n\nEmail\n IRE Training Director Alex Richards, the primary author of this course, or \ncontact him on Twitter\n\n\n\n\nWe have set aside time at the end of the workshop to work through the process of getting your home or work laptop set up with Python and a development environment. If you're looking for \na guide\n, we've put one together that covers most of what you'll need for OS X and Windows.\n\n\nEach task we'll tackle and set of lessons has finished and working versions of the code in the \"completed\" folder; they typically have \"_done\" appended to the end of the filename. If there isn't enough time to hit each one during our time together, there's enough commenting in place that you should be able to work through them on your own (and feel free to bug \nAlex\n).\n\n\nThis is designed for people who have some grounding in data journalism already and experience with spreadsheets and database managers. It's helpful if you understand Excel functions, for example, and some basic SQL. Other important skills include navigation of the computer's command line; we'll bemoving between folders, running scripts and issuing commands to a Python interpreter.\n\n\nWhat the next few days have in store\n\n\nIntroduction\n\n\nA whirlwind tour of Python's data types, variables, basic functionality and loops. We'll write a bunch of them on our own, discuss them, and then run a script in the iPython interactive interpreter to load a variety of variables and then start messing with them.\n\n\nWe'll also talk about how to format strings \u2014 which we'll be doing a ton \u2014 and how Python deals with whitespace.\n\n\nScraping data from the web\n\n\nFetching data from the web was one of programming's original beachheads in the journalism world. We're going to grab a data table from a website and turn it into a delimited text file to use in a spreadsheet or database manager.\n\n\nThis is a task one could arguably accomplish using Excel's \"import from web\" feature, so we're going to take it one step further: we'll alter our script to drill into additional detail pages and automatically extract more columns of data for our text file.\n\n\nWe'll also drill into the finer points of using the BeautifulSoup library to parse HTML, reading and writing CSV files, and targeting data with regular expressions.\n\n\nParsing records that fall across multiple lines\n\n\nData don't always arrive in a nice, neat table. We have hundreds of addresses to parse into a format that will work in Excel or a database manager, and Python is going to help us make it happen. We'll write a script that dices it all and puts everything in its proper place -- one line for one location.\n\n\nMaking a reusable function\n\n\nIn this quick project, we'll modify the address parsing script we wrote in the previous exercise, turning it into a reusable function that we can apply to future address lists that arrive in the same problematic format.\n\n\nGeocoding with Python\n\n\nGeocoding is one of those perennial data journalism problems that's gotten easier in some ways over the years, yet harder in others. While having a street address is great, having a latitude and longitude is better. We'll take the poorly formatted addresses we coaxed into a flat file and march them one at a time through an online geocoding service using a handy Python library called \ngeopy\n.\n\n\nWorking with APIs and databases\n\n\nApplication Programming Interfaces have become a common spigot for data on the web. We'll tap into one maintained by the city of Chicago that deals with crime and send it to a table in a SQLite database. From there, we'll write some scripted queries to isolate interesting information.\n\n\nWe'll also dig in on how Python interacts with databases and how it deals with dates and times.\n\n\nUnlocking data stuck in a database\n\n\nA database is a great reporting tool, having your data and analysis locked up there don't help your audience much. We're going to work with the same crime data we processed earlier and turn it into a web-friendly format (GeoJSON) for automatic display on a very basic Leaflet.js map. \n\n\nThe wonderful world of data cleaning\n\n\nOnce you figure out what the problems are with a data set, you can outsource the tedious cleaning process to Python. We'll focus on a few different types of cleaning you're likely to encounter in your reporting life, including Excel files where data is scattered around different rows and columns, CSV files with obvious errors that \n\n\nOther kinds of scrapes\n\n\nWe're not always after web tables; sometimes we're trying to collect a bunch of files scattered around a website or need to POST some data in order to get a response from a dynamic page, like a government site that uses ASP.NET. \n\n\nThe deal with text encoding and debugging your scripts\n\n\nWhat's ASCII? Why the hell am I getting \nUnicodeEncodeError\n? We'll deal sporadically with text encoding in some of these other lessons, but we'll focus on why it's important and what you can do to stay on top of it. In addition, we'll look through common errors you'll run into, what they mean and how to fix them.", 
            "title": "Main"
        }, 
        {
            "location": "/#coding-for-journalists", 
            "text": "This class is an evolving introduction to coding and the Python programming language for journalists. In addition to a tour of the fundamentals, it spans nine basic projects to get you started.  The  first version  of this course happened at the  2015 IRE Conference in Philadelphia ; the repository and associated tasks have been updated since.  A few things to note before we get rolling:   This guide and all documentation live at  coding-for-journalists.rtfd.org  The GitHub repository that includes all code is available from  github.com/ireapps/coding-for-journalists  A good place to raise issues with the code or ask specific questions about the code is  also on GitHub  Email  IRE Training Director Alex Richards, the primary author of this course, or  contact him on Twitter   We have set aside time at the end of the workshop to work through the process of getting your home or work laptop set up with Python and a development environment. If you're looking for  a guide , we've put one together that covers most of what you'll need for OS X and Windows.  Each task we'll tackle and set of lessons has finished and working versions of the code in the \"completed\" folder; they typically have \"_done\" appended to the end of the filename. If there isn't enough time to hit each one during our time together, there's enough commenting in place that you should be able to work through them on your own (and feel free to bug  Alex ).  This is designed for people who have some grounding in data journalism already and experience with spreadsheets and database managers. It's helpful if you understand Excel functions, for example, and some basic SQL. Other important skills include navigation of the computer's command line; we'll bemoving between folders, running scripts and issuing commands to a Python interpreter.", 
            "title": "Coding for Journalists"
        }, 
        {
            "location": "/#what-the-next-few-days-have-in-store", 
            "text": "Introduction  A whirlwind tour of Python's data types, variables, basic functionality and loops. We'll write a bunch of them on our own, discuss them, and then run a script in the iPython interactive interpreter to load a variety of variables and then start messing with them.  We'll also talk about how to format strings \u2014 which we'll be doing a ton \u2014 and how Python deals with whitespace.  Scraping data from the web  Fetching data from the web was one of programming's original beachheads in the journalism world. We're going to grab a data table from a website and turn it into a delimited text file to use in a spreadsheet or database manager.  This is a task one could arguably accomplish using Excel's \"import from web\" feature, so we're going to take it one step further: we'll alter our script to drill into additional detail pages and automatically extract more columns of data for our text file.  We'll also drill into the finer points of using the BeautifulSoup library to parse HTML, reading and writing CSV files, and targeting data with regular expressions.  Parsing records that fall across multiple lines  Data don't always arrive in a nice, neat table. We have hundreds of addresses to parse into a format that will work in Excel or a database manager, and Python is going to help us make it happen. We'll write a script that dices it all and puts everything in its proper place -- one line for one location.  Making a reusable function  In this quick project, we'll modify the address parsing script we wrote in the previous exercise, turning it into a reusable function that we can apply to future address lists that arrive in the same problematic format.  Geocoding with Python  Geocoding is one of those perennial data journalism problems that's gotten easier in some ways over the years, yet harder in others. While having a street address is great, having a latitude and longitude is better. We'll take the poorly formatted addresses we coaxed into a flat file and march them one at a time through an online geocoding service using a handy Python library called  geopy .  Working with APIs and databases  Application Programming Interfaces have become a common spigot for data on the web. We'll tap into one maintained by the city of Chicago that deals with crime and send it to a table in a SQLite database. From there, we'll write some scripted queries to isolate interesting information.  We'll also dig in on how Python interacts with databases and how it deals with dates and times.  Unlocking data stuck in a database  A database is a great reporting tool, having your data and analysis locked up there don't help your audience much. We're going to work with the same crime data we processed earlier and turn it into a web-friendly format (GeoJSON) for automatic display on a very basic Leaflet.js map.   The wonderful world of data cleaning  Once you figure out what the problems are with a data set, you can outsource the tedious cleaning process to Python. We'll focus on a few different types of cleaning you're likely to encounter in your reporting life, including Excel files where data is scattered around different rows and columns, CSV files with obvious errors that   Other kinds of scrapes  We're not always after web tables; sometimes we're trying to collect a bunch of files scattered around a website or need to POST some data in order to get a response from a dynamic page, like a government site that uses ASP.NET.   The deal with text encoding and debugging your scripts  What's ASCII? Why the hell am I getting  UnicodeEncodeError ? We'll deal sporadically with text encoding in some of these other lessons, but we'll focus on why it's important and what you can do to stay on top of it. In addition, we'll look through common errors you'll run into, what they mean and how to fix them.", 
            "title": "What the next few days have in store"
        }, 
        {
            "location": "/install/", 
            "text": "The ingredients for an install\n\n\nGetting to the point where you can do this at work or home can be half the battle. The good news is that it can pretty much all be had for free. Let's talk for a second about what this will require:\n\n\n\n\nA text editor\n\n\nPython\n\n\nAccess to a command line interface\n\n\npip\n\n\nvirtualenv\n\n\nvirtualenvwrapper\n\n\nA connection to the internet\n\n\n\n\nHere's what the various parts do, as well as why you need them:\n\n\nThe text editor\n allows you to write scripts for the Python interpreter in a plain text format. Something along the lines of a full word processor (think Microsoft Word or Apple's Pages) won't cut it; those are designed for presentation and resulting files will be cluttered with a bunch of elements that control text styling. Having one at your disposal is a must for writing code and great for examining data.\n\n\nPython\n is the engine of the entire affair; it's a code interpreter that's going to look at the commands you write and then faithfully execute them. At the moment this code and guide is designed around version 2.7.\n\n\nAccess to a command line interface\n in the form of the OS X terminal or Windows command prompt. It will be used to run Python scripts and access the Python interpreter.\n\n\npip\n is an external Python library that helps you manage the download and installation of packages that don't come with standard Python. There's a lot there already, sure, but people have written new modules to assist with tasks like web scraping and dealing with PDF files. It makes adding new functionality as easy as typing \npip install \nsome new package\n. \npip\n will fetch it from the internet and install it for you -- and do the same for any other packages required to make it all work correctly.\n\n\nvirtualenv\n is an external Python library that allows you to create virtual sandboxes where your scripts can live and have their own packages, completely compartmentalized from one another. It solves a problem in development where you may have conflicting package needs among different pieces of code. It also insulates you from mucking around with the core Python and \npip\n you'll be installing. When a new virtual environment is created, it springs up with its own copy of Python and \npip\n. The packages in the environment can be modified, removed and reset at will, but it will never screw with the underlying Python and \npip\n on the system, even if the environment is deleted.\n\n\nvirtualenvwrapper\n is another external Python library that just makes it easier to deal with the various virtual environments; it keeps them organized in one place, and you can easily jump in and out of environments with a few brief commands. It's important to note that the Windows command prompt has its own version (\nvirtualenvwrapper-win\n).\n\n\nA connection to the internet\n is necessary because \npip\n will be fetching packages from the web.\n\n\nOn Windows\n\n\n\n\nNote\n\n\nThis guide is for Windows 8.1. For other versions of Windows, this process should be similar.\n\n\n\n\n1. \nDownload Python 2.7\n\n\nYou'll want to download the \nmost current release of Python 2 for Windows\n; you'll likely have the best luck with the \nWindows x86 MSI installer\n.\n\n\n\n\n2. \nInstall Python 2.7\n\n\nAfter opening the installer, there are two things you'll want to include during the installation process that should make your life much easier.\n\n\nFirst, the installer will give you the option of having \npip\n ride along with the rest of the Python installation. By default, this should already be selected for you.\n\n\nSecond, the installer will give you the option to add python.exe to your PATH. All that means is that typing \npython\n at the command prompt will get you to the interpreter or give you the ability to execute a Python script, regardless of where you've navigated on your system. By default, this will \nnot\n be selected; you'll have to change it on your own.\n\n\nMake sure both of these options are selected before completing the install.\n\n\n\n\n3. \nVerify installation of Python and pip\n\n\nOpen the Windows command prompt. If you're unable to locate it in the \"Start\" menu, search for an application called \ncmd\n.\n\n\nTo check that Python was installed successfully, issue the following command:\n\n\npython --version\n\n\n\n\nIf everything went as planned, this should spit out the version number of Python you just installed. \n\n\n\n\nCaution\n\n\nIf you get an error message that says Python isn't recognized as a legitimate command, something's gone awry. Python may not have been added to your command prompt PATH, which you can resolve by following step 3 in \nthis guide\n. If the main Python directory, its Scripts folder and site-packages are all in the PATH, you'll need to attempt to reinstall.\n\n\n\n\nOnce we've verified all is well with Python, let's turn our attention to \npip\n:\n\n\npip list\n\n\n\n\nIf \npip\n was installed correctly along with Python, you should get a quick recap of nonstandard packages it can find. The output probably looks something like:\n\n\npip (7.0.1)\nsetuptools (16.0)\n\n\n\n\nIt may also have a message griping about an outdated version of \npip\n, but let's not worry about that right now.\n\n\n\n\nCaution\n\n\nIf the command prompt threw some kind of error at you, \npip\n may not be installed and there are a couple of things you can try. You can reinstall Python from the MSI file and make sure the option to install \npip\n is selected. It can also be installed manually by following \nthe instructions here\n.\n\n\n\n\n\n\n4. \nInstall virtualenv\n\n\nWith \npip\n, adding the \nvirtualenv\n package is as easy as typing:\n\n\npip install virtualenv\n\n\n\n\nIt should appear among pip and setuptools when you type \npip list\n and you should be able to verify the version with:\n\n\nvirtualenv --version\n\n\n\n\n\n\n5. \nInstall virtualenvwrapper-win\n\n\nYou may start to be seeing a pattern here with installation using \npip\n:\n\n\npip install virtualenvwrapper-win\n\n\n\n\n\n\nCaution\n\n\nIf you prefer to use a more robust command line interface like Windows PowerShell, note that the package \nvirtualenvwrapper-win\n won't work; try something like \nvirtualenvwrapper-powershell\n instead.\n\n\n\n\nThis wrapper just adds commands for easier interaction with \nvirtualenv\n. For example: Instead of having to navigate to an environment's \"Scripts\" folder and \nactivate\n it, typing \nworkon \nvirtual environment\n wherever you're navigated in the system achieves the same effect.\n\n\n\n\nCaution\n\n\nTcl\n and \ntk\n come with Python 2.7 and don't appear to automatically work inside of Windows virtualenvs; this will derail things like \n%paste\n in iPython. You'll need to navigate to the virtualenv's folder and modify the \nactivate.bat\n script by adding the following lines (with the paths to your installation of Python \u2014 defaults below): \n\n\n\n\nset \nTCL_LIBRARY=C:\\Python27\\tcl\\tcl8.5\n\nset \nTK_LIBRARY=C:\\Python27\\tcl\\tk8.5\n\n\n\n\n\n\nOther ways into Python on Windows\n\n\nIn recent years IRE has been teaching Python in PC labs, and the easiest way to get everyone set up quickly has been to use the \nAnaconda distribution of Python\n, which comes with many popular nonstandard libraries already installed alongside the core program.\n\n\nThis remains an option available to you; it comes with \npip\n and has its own method of segregating projects into virtual environments.\n\n\n\n\nOn OS X\n\n\nPython comes pre-installed on OS X, which actually makes the process of getting set up properly more difficult.\n\n\nYes, more difficult.\n\n\nThe version accompanying OS X has been tinkered with by Apple, and it's responsible for other functionality on your computer. It's also likely out of date.\n\n\nThe accepted way to get around this problem is to install an OS X program called \nHomebrew\n, which is essentially a package manager for your system \u2014 similar to what pip does for Python. It will allow you to download an independent and updateable version of Python that you can use going forward. A side benefit is that pip comes with the Python you install with Homebrew.\n\n\nNot to evangelize about Homebrew too much, but if you decide to travel down the path leading to some of the more complex data journalism techniques on the command line, you'll find other uses for Homebrew and its many packages beyond just providing a clean copy of Python.\n\n\nIt has downsides; Homebrew requires a current version of Apple's Xcode's command line tools to be installed on your computer first. A full guide is \navailable here\n to get you up and running.\n\n\n\n\nCaution\n\n\nChanges in OS X 10.11 El Capitan can make this process even trickier. Apple insituted extra system protections that have the capability of adding a few steps to the Homebrew install process. If you're running into these issues, \nread this\n for more information.\n\n\n\n\n\n\nNote\n\n\nYou can also use the built-in OS X Python if you wish. The next step in that case will be getting pip up and running.\n\n\n\n\n1. \nCheck for pip\n\n\nHomebrew's Python comes with pip in tow. If you're using the OS X system version, let's see if it's installed. Open the Terminal and type the following:\n\n\npip -V\n\n\n\n\nIf pip is installed, this will return a version number.\n\n\n\n\n2. \nIf it's not there: Get pip\n\n\nDownload \nget-pip.py\n, navigate to it and type the following:\n\n\npython get-pip.py\n\n\n\n\nFor more information on installing pip, there's a \nwalkthrough\n as a part of its online documentation.\n\n\n\n\n3. \nVerify the presence of Python and pip\n\n\nLet's see what we're working with here and check to make sure all is well:\n\n\npython -V\npip -V\n\n\n\n\n\n\n4. \nGet and install virtualenv\n\n\nWith \npip\n, adding the \nvirtualenv\n package is as easy as typing:\n\n\npip install virtualenv\n\n\n\n\nIt should appear among pip and setuptools when you type \npip list\n and you should be able to verify the version with:\n\n\nvirtualenv --version\n\n\n\n\n\n\n5. \nGet and install virtualenvwrapper\n\n\nWe can install virtualenvwrapper with \npip\n as well:\n\n\npip install virtualenvwrapper\n\n\n\n\nThis wrapper just adds commands for easier interaction with \nvirtualenv\n. For example: Instead of having to navigate to an environment's \"Scripts\" folder and \nactivate\n it, typing \nworkon \nvirtual environment\n wherever you're navigated in the system achieves the same effect.\n\n\n\n\n6. \nModify your .bash_profile so you can use virtualenvwrapper commands and give your virtualenvs a home\n\n\nThis can be accomplished by opening your .bash_profile, which is typically in your main user directory. Typing:\n\n\nopen -e ~/.bash_profile\n\n\n\n\nOpens the file in your system's default text editor \u2014 probably TextEdit.\n\n\nIf you get an error saying that the file doesn't exist, create one and then try opening it again.\n\n\ntouch ~/.bash_profile\nopen -e ~/.bash_profile\n\n\n\n\n\n\n7. \nReload your .bash_profile\n\n\nSo that these new changes take effect, type:\n\n\nsource ~/.bash_profile\n\n\n\n\n\n\nTest run\n\n\nmkvirtualenv mytest\ndeactivate\nworkon\nworkon mytest\npip list mytest\n\n\n\n\n\n\nGetting \"Coding for Journalists\"\n\n\nA repository for all of the files is presently hosted on GitHub, which is likely how you navigated here in the first place. You can just \ncopy a zipped version\n of all the files for your use or fork it using GitHub's desktop application or git from the command line. For help with git and GitHub, there are some \nresources in \"Next Steps.\"\n\n\nOnce you have the files, you'll need to set up a virtualenv told hold the required libraries.\n\n\nmkvirtualenv cfj\n\n\n\n\nYou should automatically be placed inside the new virtualenv after creation. From there, the \nrequirements.txt\n file within the main folder lists every necessary library to make these scripts run.\n\n\npip install -r requirements.txt\n\n\n\n\n\n\nCaution\n\n\nOne requirement isn't designed for Windows, so there is a separate file \nrequirements-win.txt\n that should be used instead.\n\n\n\n\nOnce that's done, you'll have non-standard Python libraries and add-ons like \ngeopy\n, \niPython\n and \nrequests\n at your disposal.", 
            "title": "Setting up your computer"
        }, 
        {
            "location": "/install/#the-ingredients-for-an-install", 
            "text": "Getting to the point where you can do this at work or home can be half the battle. The good news is that it can pretty much all be had for free. Let's talk for a second about what this will require:   A text editor  Python  Access to a command line interface  pip  virtualenv  virtualenvwrapper  A connection to the internet   Here's what the various parts do, as well as why you need them:  The text editor  allows you to write scripts for the Python interpreter in a plain text format. Something along the lines of a full word processor (think Microsoft Word or Apple's Pages) won't cut it; those are designed for presentation and resulting files will be cluttered with a bunch of elements that control text styling. Having one at your disposal is a must for writing code and great for examining data.  Python  is the engine of the entire affair; it's a code interpreter that's going to look at the commands you write and then faithfully execute them. At the moment this code and guide is designed around version 2.7.  Access to a command line interface  in the form of the OS X terminal or Windows command prompt. It will be used to run Python scripts and access the Python interpreter.  pip  is an external Python library that helps you manage the download and installation of packages that don't come with standard Python. There's a lot there already, sure, but people have written new modules to assist with tasks like web scraping and dealing with PDF files. It makes adding new functionality as easy as typing  pip install  some new package .  pip  will fetch it from the internet and install it for you -- and do the same for any other packages required to make it all work correctly.  virtualenv  is an external Python library that allows you to create virtual sandboxes where your scripts can live and have their own packages, completely compartmentalized from one another. It solves a problem in development where you may have conflicting package needs among different pieces of code. It also insulates you from mucking around with the core Python and  pip  you'll be installing. When a new virtual environment is created, it springs up with its own copy of Python and  pip . The packages in the environment can be modified, removed and reset at will, but it will never screw with the underlying Python and  pip  on the system, even if the environment is deleted.  virtualenvwrapper  is another external Python library that just makes it easier to deal with the various virtual environments; it keeps them organized in one place, and you can easily jump in and out of environments with a few brief commands. It's important to note that the Windows command prompt has its own version ( virtualenvwrapper-win ).  A connection to the internet  is necessary because  pip  will be fetching packages from the web.", 
            "title": "The ingredients for an install"
        }, 
        {
            "location": "/install/#on-windows", 
            "text": "Note  This guide is for Windows 8.1. For other versions of Windows, this process should be similar.   1.  Download Python 2.7  You'll want to download the  most current release of Python 2 for Windows ; you'll likely have the best luck with the  Windows x86 MSI installer .   2.  Install Python 2.7  After opening the installer, there are two things you'll want to include during the installation process that should make your life much easier.  First, the installer will give you the option of having  pip  ride along with the rest of the Python installation. By default, this should already be selected for you.  Second, the installer will give you the option to add python.exe to your PATH. All that means is that typing  python  at the command prompt will get you to the interpreter or give you the ability to execute a Python script, regardless of where you've navigated on your system. By default, this will  not  be selected; you'll have to change it on your own.  Make sure both of these options are selected before completing the install.   3.  Verify installation of Python and pip  Open the Windows command prompt. If you're unable to locate it in the \"Start\" menu, search for an application called  cmd .  To check that Python was installed successfully, issue the following command:  python --version  If everything went as planned, this should spit out the version number of Python you just installed.    Caution  If you get an error message that says Python isn't recognized as a legitimate command, something's gone awry. Python may not have been added to your command prompt PATH, which you can resolve by following step 3 in  this guide . If the main Python directory, its Scripts folder and site-packages are all in the PATH, you'll need to attempt to reinstall.   Once we've verified all is well with Python, let's turn our attention to  pip :  pip list  If  pip  was installed correctly along with Python, you should get a quick recap of nonstandard packages it can find. The output probably looks something like:  pip (7.0.1)\nsetuptools (16.0)  It may also have a message griping about an outdated version of  pip , but let's not worry about that right now.   Caution  If the command prompt threw some kind of error at you,  pip  may not be installed and there are a couple of things you can try. You can reinstall Python from the MSI file and make sure the option to install  pip  is selected. It can also be installed manually by following  the instructions here .    4.  Install virtualenv  With  pip , adding the  virtualenv  package is as easy as typing:  pip install virtualenv  It should appear among pip and setuptools when you type  pip list  and you should be able to verify the version with:  virtualenv --version   5.  Install virtualenvwrapper-win  You may start to be seeing a pattern here with installation using  pip :  pip install virtualenvwrapper-win   Caution  If you prefer to use a more robust command line interface like Windows PowerShell, note that the package  virtualenvwrapper-win  won't work; try something like  virtualenvwrapper-powershell  instead.   This wrapper just adds commands for easier interaction with  virtualenv . For example: Instead of having to navigate to an environment's \"Scripts\" folder and  activate  it, typing  workon  virtual environment  wherever you're navigated in the system achieves the same effect.   Caution  Tcl  and  tk  come with Python 2.7 and don't appear to automatically work inside of Windows virtualenvs; this will derail things like  %paste  in iPython. You'll need to navigate to the virtualenv's folder and modify the  activate.bat  script by adding the following lines (with the paths to your installation of Python \u2014 defaults below):    set  TCL_LIBRARY=C:\\Python27\\tcl\\tcl8.5 \nset  TK_LIBRARY=C:\\Python27\\tcl\\tk8.5   Other ways into Python on Windows  In recent years IRE has been teaching Python in PC labs, and the easiest way to get everyone set up quickly has been to use the  Anaconda distribution of Python , which comes with many popular nonstandard libraries already installed alongside the core program.  This remains an option available to you; it comes with  pip  and has its own method of segregating projects into virtual environments.", 
            "title": "On Windows"
        }, 
        {
            "location": "/install/#on-os-x", 
            "text": "Python comes pre-installed on OS X, which actually makes the process of getting set up properly more difficult.  Yes, more difficult.  The version accompanying OS X has been tinkered with by Apple, and it's responsible for other functionality on your computer. It's also likely out of date.  The accepted way to get around this problem is to install an OS X program called  Homebrew , which is essentially a package manager for your system \u2014 similar to what pip does for Python. It will allow you to download an independent and updateable version of Python that you can use going forward. A side benefit is that pip comes with the Python you install with Homebrew.  Not to evangelize about Homebrew too much, but if you decide to travel down the path leading to some of the more complex data journalism techniques on the command line, you'll find other uses for Homebrew and its many packages beyond just providing a clean copy of Python.  It has downsides; Homebrew requires a current version of Apple's Xcode's command line tools to be installed on your computer first. A full guide is  available here  to get you up and running.   Caution  Changes in OS X 10.11 El Capitan can make this process even trickier. Apple insituted extra system protections that have the capability of adding a few steps to the Homebrew install process. If you're running into these issues,  read this  for more information.    Note  You can also use the built-in OS X Python if you wish. The next step in that case will be getting pip up and running.   1.  Check for pip  Homebrew's Python comes with pip in tow. If you're using the OS X system version, let's see if it's installed. Open the Terminal and type the following:  pip -V  If pip is installed, this will return a version number.   2.  If it's not there: Get pip  Download  get-pip.py , navigate to it and type the following:  python get-pip.py  For more information on installing pip, there's a  walkthrough  as a part of its online documentation.   3.  Verify the presence of Python and pip  Let's see what we're working with here and check to make sure all is well:  python -V\npip -V   4.  Get and install virtualenv  With  pip , adding the  virtualenv  package is as easy as typing:  pip install virtualenv  It should appear among pip and setuptools when you type  pip list  and you should be able to verify the version with:  virtualenv --version   5.  Get and install virtualenvwrapper  We can install virtualenvwrapper with  pip  as well:  pip install virtualenvwrapper  This wrapper just adds commands for easier interaction with  virtualenv . For example: Instead of having to navigate to an environment's \"Scripts\" folder and  activate  it, typing  workon  virtual environment  wherever you're navigated in the system achieves the same effect.   6.  Modify your .bash_profile so you can use virtualenvwrapper commands and give your virtualenvs a home  This can be accomplished by opening your .bash_profile, which is typically in your main user directory. Typing:  open -e ~/.bash_profile  Opens the file in your system's default text editor \u2014 probably TextEdit.  If you get an error saying that the file doesn't exist, create one and then try opening it again.  touch ~/.bash_profile\nopen -e ~/.bash_profile   7.  Reload your .bash_profile  So that these new changes take effect, type:  source ~/.bash_profile", 
            "title": "On OS X"
        }, 
        {
            "location": "/install/#test-run", 
            "text": "mkvirtualenv mytest\ndeactivate\nworkon\nworkon mytest\npip list mytest", 
            "title": "Test run"
        }, 
        {
            "location": "/install/#getting-coding-for-journalists", 
            "text": "A repository for all of the files is presently hosted on GitHub, which is likely how you navigated here in the first place. You can just  copy a zipped version  of all the files for your use or fork it using GitHub's desktop application or git from the command line. For help with git and GitHub, there are some  resources in \"Next Steps.\"  Once you have the files, you'll need to set up a virtualenv told hold the required libraries.  mkvirtualenv cfj  You should automatically be placed inside the new virtualenv after creation. From there, the  requirements.txt  file within the main folder lists every necessary library to make these scripts run.  pip install -r requirements.txt   Caution  One requirement isn't designed for Windows, so there is a separate file  requirements-win.txt  that should be used instead.   Once that's done, you'll have non-standard Python libraries and add-ons like  geopy ,  iPython  and  requests  at your disposal.", 
            "title": "Getting \"Coding for Journalists\""
        }, 
        {
            "location": "/pt1/", 
            "text": "Introduction\n\n\nBefore we do anything, we need to understand some of the components we'll be interacting with and switching between.\n\n\n\n\n\n\nThe Python interpreter\n: we input commands, define variables and functions, write loops, etc. The interpreter parses it all for us, line by line as we write them, and takes action.\n\n\n\n\n\n\nText editor\n: this is where we essentially chain a bunch of commands together within a single document and save it as a Python script (ending in \n.py\n).\n\n\n\n\n\n\nThe command line\n: Accessed via \"Terminal\" on OS X or \"cmd.exe\" (or possibly PowerShell) on Windows. It's where we run the Python interpreter, among other programs, and issue commands that allow us to navigate our computer's folders.\n\n\n\n\n\n\nThat's pretty much it. These three pieces give you a container for code you're writing, the program to run it and a method to get it all running. We'll be doing some switching back and forth between entering code directly into the interpreter we run from the command line and the text editor.\n\n\nAs we progress, we'll be dealing with two other things.\n\n\n\n\n\n\nExternal libraries\n: Python comes with a standard library that has a ton of useful stuff. Developers have written libraries that take this functionality even further. By importing parts of these libraries into our Python script, we can do complex things, like fetch a web page, with a single line of code.\n\n\n\n\n\n\nA virtual enviroment\n: The bubble where all of our code lives.\n\n\n\n\n\n\nThis is a crash course in some of Python's major data types and and how to tame them. We'll be doing things like mashing strings together, running through items in a list and defining very simple functions.\n\n\nWe'll be using iPython's interactive interpreter, which means we have access to a few extra features (which iPython modestly calls \nmagic functions\n).\n\n\nThe files in this folder:\n\n\n\n\n\n\nvar.py\n: A Python script with some variables of different types like integers, lists and dictionaries.\n\n\n\n\n\n\nexercises.py\n: A file that gives a list of exercises in the form of comments; guidance on how to manipulate the variables in \nvar.py\n. It's also the place we can write code to save for future reference. Nearly everything we do in this task will use iPython.\n\n\n\n\n\n\nfun_with_subs.py\n: A file for practicing string substitutions, which is something we'll be doing frequently. It covers the depreciated method you'll encounter frequently and covers \nstr.format()\n.\n\n\n\n\n\n\nwhitespace.py\n: A guide to how Python decides which blocks of code to run when; it's all controlled by indentation.\n\n\n\n\n\n\nAny finished versions will appear in the \ncompleted\n folder.\n\n\nOpening iPython is as easy as typing \nipython\n into PowerShell.\n\n\nTo get everything from \nvar.py\n queued up, we can either run it from within iPython using one of the \nmagic functions\n:\n\n\n%run var.py\n\n\n\n\nOr we can use the more traditional method of importing everything defined in a script, treating it as a module:\n\n\nfrom var import *\n\n\n\n\nThis will make a little more sense as we start bringing in other Python libraries to tackle our other tasks. Either way, it's going to get us those variables defined in \nvar.py\n. We can quickly test that these variables were loaded by typing \nlucky_number\n.\n\n\nLet's say I have a longer chunk of code that I want to try out in iPython to see if it works as expected.\n\n\npresents = ['A brand new car', 'Socks']\n\nfor gift in presents:\n    if gift == 'A brand new car':\n        print gift, '\n- Oh yeah!'\n    else:\n        print gift, '\n- Meh.'\n\n\n\n\nHaving to type this line by line into the interpreter and pay attention to indentation can be a pain.\n\n\nBut I can write that block of code in a text editor instead, then select it all and copy it. Switching over to iPython, I can use the built-in paste function:\n\n\n%paste\n\n\n\n\nThis will paste the contents of my clipboard, preserving all the indentation and other white space, and execute whatever code was there. Pretty handy.\n\n\nFinally, iPython has another function that will give you a recap of commands you've typed:\n\n\n%history", 
            "title": "Introduction"
        }, 
        {
            "location": "/pt2/", 
            "text": "2_web_scrape\n\n\nNow that we've familiarized ourselves with the ways Python works, we have a little bit of a foundation to build from. Nearly everything else we do today is going to be using the fundamentals from \n1_start\n to varying degrees and in different combinations to create longer scripts.\n\n\nSo let's scrape a web page. We want to collect all the data from the main table on the U.S. Nuclear Regulatory Commission's \nlist of domestic power reactor units\n.\n\n\nPython comes with a library installed that's designed specifically for reading and writing CSV files (\ncsv\n), but we're also going to need to extend Python's functionality a bit by bringing in two other libraries.\n\n\nOne is \nrequests\n -- it handles the job of playing a web browser that can fetch a web page and send back the underlying HTML. The other is \nBeautifulSoup\n, which parses the HTML into what amounts to a series of lists that we can then search, navigate and extract data from.\n\n\nWhen we get to part two, we'll use the built-in regular expressions library \nre\n to isolate some text from the detail pages and \ntime\n to keep us from swamping a government site with too many requests at once.\n\n\nA big thank you to \nAnthony DeBarros\n for allowing us to present a modified version of his web scraping example from \npython-get-started\n.\n\n\nThis exercise contains six files:\n\n\n\n\n\n\nscrape.py\n: The file we'll use to write our scraping script, following the comments.\n\n\n\n\n\n\nscrape_pt2.py\n: The file we'll use to push our scraping script further; it contains finished code for \nscrape.py\n and open spots to add code that loops through to detail pages and collects additional information.\n\n\n\n\n\n\nnrc_backup.html\n: A backup version of the main table we want to scrape in case there's a connection problem.\n\n\n\n\n\n\ntable_example.html\n: A bare bones HTML table that shows the basic tags and how they're nested, with the flourishes of a modern web page stripped away -- it's ugly.\n\n\n\n\n\n\nscrape_done.py\n: A completed and working version of \nscrape.py\n.\n\n\n\n\n\n\nscrape_pt2_done.py\n: A completed and working version of \nscrape_pt2.py\n.", 
            "title": "Scraping the web"
        }, 
        {
            "location": "/pt2/#295web_scrape", 
            "text": "Now that we've familiarized ourselves with the ways Python works, we have a little bit of a foundation to build from. Nearly everything else we do today is going to be using the fundamentals from  1_start  to varying degrees and in different combinations to create longer scripts.  So let's scrape a web page. We want to collect all the data from the main table on the U.S. Nuclear Regulatory Commission's  list of domestic power reactor units .  Python comes with a library installed that's designed specifically for reading and writing CSV files ( csv ), but we're also going to need to extend Python's functionality a bit by bringing in two other libraries.  One is  requests  -- it handles the job of playing a web browser that can fetch a web page and send back the underlying HTML. The other is  BeautifulSoup , which parses the HTML into what amounts to a series of lists that we can then search, navigate and extract data from.  When we get to part two, we'll use the built-in regular expressions library  re  to isolate some text from the detail pages and  time  to keep us from swamping a government site with too many requests at once.  A big thank you to  Anthony DeBarros  for allowing us to present a modified version of his web scraping example from  python-get-started .  This exercise contains six files:    scrape.py : The file we'll use to write our scraping script, following the comments.    scrape_pt2.py : The file we'll use to push our scraping script further; it contains finished code for  scrape.py  and open spots to add code that loops through to detail pages and collects additional information.    nrc_backup.html : A backup version of the main table we want to scrape in case there's a connection problem.    table_example.html : A bare bones HTML table that shows the basic tags and how they're nested, with the flourishes of a modern web page stripped away -- it's ugly.    scrape_done.py : A completed and working version of  scrape.py .    scrape_pt2_done.py : A completed and working version of  scrape_pt2.py .", 
            "title": "2_web_scrape"
        }, 
        {
            "location": "/pt3/", 
            "text": "3_parse_addresses\n\n\nIt would be great if every piece of data you came across was in a format that lent itself to easy capture. In the same vein as the text extraction from reactor detail pages in our last example, we're going to pick apart an HTML file of licensed payday lenders (that's mostly text) and turn it into a flat CSV file where one row is one record.\n\n\nIn this file, addresses can span three, four or five lines. Sometimes it's on four lines because a lender does business in Illinois under another name; in others, it's because the lender operates out of a suite, room or building stored on a line separate from the street address. This means that our script needs to behave four different ways depending on how many lines it encounters for each address, and we'll switch among those behaviors with \nif/elif\n syntax.\n\n\nWe'll again use \nBeautifulSoup\n, but primarily to break out the portion of the file we want to capture for the resulting CSV.\n\n\nThis exercise has three files:\n\n\n\n\n\n\npayday.py\n: The file we'll use to write our address parser, following the comments.\n\n\n\n\n\n\npayday_lenders.html\n: A simple HTML file that lists nearly 500 payday lenders licensed to do business in Illinois. Their addresses are split across multiple lines.\n\n\n\n\n\n\npayday_done.py\n: A completed and working version of \npayday.py\n.", 
            "title": "Parsing text across lines"
        }, 
        {
            "location": "/pt3/#395parse_addresses", 
            "text": "It would be great if every piece of data you came across was in a format that lent itself to easy capture. In the same vein as the text extraction from reactor detail pages in our last example, we're going to pick apart an HTML file of licensed payday lenders (that's mostly text) and turn it into a flat CSV file where one row is one record.  In this file, addresses can span three, four or five lines. Sometimes it's on four lines because a lender does business in Illinois under another name; in others, it's because the lender operates out of a suite, room or building stored on a line separate from the street address. This means that our script needs to behave four different ways depending on how many lines it encounters for each address, and we'll switch among those behaviors with  if/elif  syntax.  We'll again use  BeautifulSoup , but primarily to break out the portion of the file we want to capture for the resulting CSV.  This exercise has three files:    payday.py : The file we'll use to write our address parser, following the comments.    payday_lenders.html : A simple HTML file that lists nearly 500 payday lenders licensed to do business in Illinois. Their addresses are split across multiple lines.    payday_done.py : A completed and working version of  payday.py .", 
            "title": "3_parse_addresses"
        }, 
        {
            "location": "/pt4/", 
            "text": "4_make_function\n\n\nThis is a pretty quick task -- the next time we have to deal with a list from the same agency, we shouldn't have to spend time rewriting our code from scratch or even go back to revise it to handle a new file. We have something that works, so let's turn it into a function we can call whenever we need to parse addresses for a list of financial licensees.\n\n\nThis exercise contains five files:\n\n\npayday_parser.py\n: Our parser from \n3_parse_addresses\n. We'll turn the existing work into a function and generalize it a bit to handle a file that's not specifically the list of licensed payday lenders.\n\n\nconsumer_installment.html\n: Another listing from the state of Illinois, but this time it encompasses more than 1,000 licensed consumer installment lenders.\n\n\ncall_function.py\n: A script we'll write to call the parser function from \npayday_parser.py\n and direct it toward our HTML file.\n\n\npayday_parser_done.py\n: A completed and working version of \npayday_parser.py\n.\n\n\ncall_function_done.py\n: A completed and working version of \ncall_function.py\n.", 
            "title": "Making a function"
        }, 
        {
            "location": "/pt4/#495make_function", 
            "text": "This is a pretty quick task -- the next time we have to deal with a list from the same agency, we shouldn't have to spend time rewriting our code from scratch or even go back to revise it to handle a new file. We have something that works, so let's turn it into a function we can call whenever we need to parse addresses for a list of financial licensees.  This exercise contains five files:  payday_parser.py : Our parser from  3_parse_addresses . We'll turn the existing work into a function and generalize it a bit to handle a file that's not specifically the list of licensed payday lenders.  consumer_installment.html : Another listing from the state of Illinois, but this time it encompasses more than 1,000 licensed consumer installment lenders.  call_function.py : A script we'll write to call the parser function from  payday_parser.py  and direct it toward our HTML file.  payday_parser_done.py : A completed and working version of  payday_parser.py .  call_function_done.py : A completed and working version of  call_function.py .", 
            "title": "4_make_function"
        }, 
        {
            "location": "/pt5/", 
            "text": "5_geocode\n\n\nFor any kind of analysis that involves mapping, having coordinates is a must. En masse, though, they aren't always easy to come by.\n\n\nOpen-source geographic information systems like \nQGIS\n don't have built-in options to figure out a location's latitude and longitude; \nEsri\n charges for some of its online geocoding services, too.\n\n\nEnter \ngeopy\n, a Python library that's designed to interact with a slew of third-party geolocation APIs. As part of a larger script, we can read lines of address data from a CSV file, send each through one of these services and return the results.\n\n\nIn this example, we'll be using Google's geocoding service, which is good at properly interpreting an address string even when it's partially malformed or contains extraneous information. As a free service, however, it will only geocode 2,500 addresses in a 24-hour period.\n\n\nWe'll be using the CSV file we made by parsing payday lender addresses from 3_parse_addresses. Our goal at the end is to have a new CSV file with three additional fields of information:\n\n\n\n\nGoogle's match for the address\n\n\nLatitude in decimal degrees (Y coordinate)\n\n\nLongitude in decimal degrees (X coordinate)\n\n\n\n\nGoogle's free geocoder can only handle five requests per second, so we're going to use Python's time functions to slow our requests down and set up a control flow so that we're all only geocoding the first five addresses -- a condition that can be removed at your discretion if you're working through this task on your own later.\n\n\nThis exercise contains three files:\n\n\n\n\n\n\ngeocode.py\n: A script we'll write to pass addresses through Google's geocoding service. It will take the results along with our initial data fields and send them all to a new CSV file.\n\n\n\n\n\n\npayday_lenders.csv\n: Our completed CSV file from 3_parse_addresses.\n\n\n\n\n\n\ngeocode_done.py\n: A completed and working version of \ngeocode.py\n.", 
            "title": "Geocoding addresses"
        }, 
        {
            "location": "/pt5/#5_geocode", 
            "text": "For any kind of analysis that involves mapping, having coordinates is a must. En masse, though, they aren't always easy to come by.  Open-source geographic information systems like  QGIS  don't have built-in options to figure out a location's latitude and longitude;  Esri  charges for some of its online geocoding services, too.  Enter  geopy , a Python library that's designed to interact with a slew of third-party geolocation APIs. As part of a larger script, we can read lines of address data from a CSV file, send each through one of these services and return the results.  In this example, we'll be using Google's geocoding service, which is good at properly interpreting an address string even when it's partially malformed or contains extraneous information. As a free service, however, it will only geocode 2,500 addresses in a 24-hour period.  We'll be using the CSV file we made by parsing payday lender addresses from 3_parse_addresses. Our goal at the end is to have a new CSV file with three additional fields of information:   Google's match for the address  Latitude in decimal degrees (Y coordinate)  Longitude in decimal degrees (X coordinate)   Google's free geocoder can only handle five requests per second, so we're going to use Python's time functions to slow our requests down and set up a control flow so that we're all only geocoding the first five addresses -- a condition that can be removed at your discretion if you're working through this task on your own later.  This exercise contains three files:    geocode.py : A script we'll write to pass addresses through Google's geocoding service. It will take the results along with our initial data fields and send them all to a new CSV file.    payday_lenders.csv : Our completed CSV file from 3_parse_addresses.    geocode_done.py : A completed and working version of  geocode.py .", 
            "title": "5_geocode"
        }, 
        {
            "location": "/pt6/", 
            "text": "", 
            "title": "APIs and databases"
        }, 
        {
            "location": "/pt7/", 
            "text": "", 
            "title": "Unlocking data from databases"
        }, 
        {
            "location": "/pt8/", 
            "text": "", 
            "title": "Cleaning data"
        }, 
        {
            "location": "/pt9/", 
            "text": "", 
            "title": "Other scrapes"
        }, 
        {
            "location": "/pt10/", 
            "text": "", 
            "title": "Text encoding and debugging"
        }, 
        {
            "location": "/next_steps/", 
            "text": "Next Steps\n\n\nIf you're curious about the different paths for installing Python and various libraries on your own computer, some excellent resources exist as part of the \nPyCAR\n repository. The \ntake-home portion\n points to several tutorials and guides that cover Mac and PC setup, how to compartmentalize projects in their own virtual environments and the use of version control.\n\n\nIf you want to use a virtualenv, we've included a (short) requirements file for \npip\n with all the non-standard libraries used and their dependencies.\n\n\nHere are stops to make as you expand your knowledge and keep practicing these news skills:\n\n\n\n\nAgain, the \nPyCAR\n repository, a daylong class taught at the 2014 and 2015 NICAR Conferences.\n\n\nAnthony Debarros' \npython-get-started\n repository and his useful \npython-snippets\n, a list of practical code examples.\n\n\nBen Welsh's updated guide to building \na web scraper in Python\n and his guide for building \na lightweight news app\n.\n\n\nLearnPython\n is an interactive tutorial that covers a lot of this same ground and more.\n\n\n\n\nVersion control\n\n\nAs you start feeling more comfortable with the basics, you may want to start using a version control setup like \ngit\n to catalog your scripts, collaborate with others and share your code with the world.\n\n\nHere are a couple of guides from NICAR presenters and other sources that may come in handy:\n\n\n\n\nTom Meagher's \ntipsheet on git and GitHub\n\n\nResources and code shared during NICAR15\n from the fine folks at GitHub \n\n\nLauren Orsini's \nguide for beginners\n\n\nGitHub's own \ncommand cheat sheet", 
            "title": "Next steps"
        }
    ]
}